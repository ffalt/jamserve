{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"fs-extra\"","webpack:///./src/utils/fs-utils.ts","webpack:///./src/modules/audio/tasks/task-rewrite-mp3.ts","webpack:///external \"jamp3\"","webpack:///external \"worker_threads\"","webpack:///./src/model/jam-types.ts","webpack:///external \"path\"","webpack:///./src/modules/audio/tools/ffmpeg-rewrite.ts","webpack:///external \"fluent-ffmpeg\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","pathName","pathExists","unlink","remove","filename","extname","slice","toLowerCase","basename","replace","toString","FolderSystemCharsRegEx","test","length","sep","parentPort","on","param","Error","tempFile","backupFile","suffix","fileSuffix","id3v2","ID3v2","tag","AudioFormatType","mp3","read","rewriteWriteFFmpeg","fileDeleteIfExists","copy","write","keepBackup","paddingSize","rename","e","Promise","reject","rewriteAudio","postMessage","undefined","WaveformFormatType","FolderType","AlbumType","JamObjectType","RootScanStrategy","AudioMimeTypes","m4a","mp4","ogg","oga","flv","flac","webma","webm","wav","VideoMimeTypes","m4v","ogv","webmv","PodcastStatus","FolderTypeImageName","unknown","artist","collection","album","multialbum","extras","ArtworkImageType","FolderTypesAlbum","DatabaseQuerySortType","AlbumTypesArtistMusic","live","bootleg","ep","single","FileTyp","LastFMLookupType","MusicBrainzLookupType","MusicBrainzSearchType","CoverArtArchiveLookupType","TrackTagFormatType","MusicBrainzAlbumPrimaryType","MusicBrainzAlbumSecondaryType","MUSICBRAINZ_VARIOUS_ARTISTS_ID","MUSICBRAINZ_VARIOUS_ARTISTS_NAME","cUnknownArtist","cUnknownAlbum","TrackHealthID","FolderHealthID","AudioFormats","DownloadFormats","DefaultDownloadFormat","WaveformFormats","WaveformDefaultFormat","svg","destination","resolve","proc","source","addOption","output","format","err","run"],"mappings":"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","file":"task-rewrite-mp3.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"fs-extra\");","import fse from 'fs-extra';\nimport path from 'path';\n\nexport async function fileDeleteIfExists(pathName: string): Promise<void> {\n\tconst exists = await fse.pathExists(pathName);\n\tif (exists) {\n\t\tawait fse.unlink(pathName);\n\t}\n}\n\nexport async function pathDeleteIfExists(pathName: string): Promise<void> {\n\tconst exists = await fse.pathExists(pathName);\n\tif (exists) {\n\t\tawait fse.remove(pathName);\n\t}\n}\n\nexport function fileSuffix(filename: string): string {\n\treturn path.extname(filename).slice(1).toLowerCase();\n}\n\nexport function fileExt(filename: string): string {\n\treturn path.extname(filename).toLowerCase();\n}\n\nexport function basenameStripExt(filename: string): string {\n\treturn path.basename(filename, path.extname(filename));\n}\n\nexport function replaceFileSystemChars(s: string, replace: string): string {\n\treturn s.toString()\n\t\t.replace(/:/g, ' - ')\n\t\t.replace(/[?/!\\\\\"]/g, replace);\n}\n\n// eslint-disable-next-line no-control-regex\nconst FolderSystemCharsRegEx = /[<>:\"/\\\\|?*\\x00-\\x1F]|^(?:aux|con|clock\\$|nul|prn|com[1-9]|lpt[1-9])$/i;\n\nexport function containsFolderSystemChars(s: string): boolean {\n\treturn FolderSystemCharsRegEx.test(s);\n}\n\nexport function replaceFolderSystemChars(s: string, replace: string): string {\n\t/*\n\t\t< (less than)\n\t\t> (greater than)\n\t\t: (colon)\n\t\t\" (double quote)\n\t\t/ (forward slash)\n\t\t\\ (backslash)\n\t\t| (vertical bar or pipe)\n\t\t? (question mark)\n\t\t* (asterisk)\n\t */\n\treturn s.toString()\n\t\t.replace(/:/g, ' -')\n\t\t.replace(/[|*?/!\\\\<>\"]/g, replace);\n}\n\nexport function ensureTrailingPathSeparator(s: string): string {\n\tif (s.length > 0 && s[s.length - 1] !== path.sep) {\n\t\treturn s + path.sep;\n\t}\n\treturn s;\n}\n\nexport function removeTrailingPathSeparator(s: string): string {\n\tif (s.length > 0 && s[s.length - 1] === path.sep) {\n\t\treturn s.slice(0, s.length - 1);\n\t}\n\treturn s;\n}\n","import fse from 'fs-extra';\nimport {ID3v2, IID3V2} from 'jamp3';\nimport {parentPort} from 'worker_threads';\nimport {AudioFormatType} from '../../../model/jam-types';\nimport {fileDeleteIfExists, fileSuffix} from '../../../utils/fs-utils';\nimport {rewriteWriteFFmpeg} from '../tools/ffmpeg-rewrite';\n\nasync function rewriteAudio(param: string): Promise<void> {\n\tconst tempFile = `${param}.tmp`;\n\tconst backupFile = `${param}.bak`;\n\ttry {\n\t\tconst suffix = fileSuffix(param);\n\t\tconst id3v2 = new ID3v2();\n\t\tlet tag: IID3V2.Tag | undefined;\n\t\tif (suffix === AudioFormatType.mp3) {\n\t\t\ttag = await id3v2.read(param);\n\t\t}\n\t\tawait rewriteWriteFFmpeg(param, tempFile);\n\t\tconst exits = await fse.pathExists(backupFile);\n\t\tif (exits) {\n\t\t\tawait fileDeleteIfExists(param);\n\t\t} else {\n\t\t\tawait fse.copy(param, backupFile);\n\t\t}\n\t\tif (tag) {\n\t\t\tawait id3v2.write(tempFile, tag, 4, 0, {keepBackup: false, paddingSize: 10});\n\t\t}\n\t\tawait fse.rename(tempFile, param);\n\t} catch (e) {\n\t\tawait fileDeleteIfExists(tempFile);\n\t\treturn Promise.reject(e);\n\t}\n}\n\nif (parentPort) {\n\tparentPort.on('message', async (param: any) => {\n\t\tif (typeof param !== 'string') {\n\t\t\tthrow new Error('param must be a string.');\n\t\t}\n\t\tawait rewriteAudio(param);\n\t\tif (parentPort) {\n\t\t\tparentPort.postMessage(undefined);\n\t\t}\n\t});\n}\n","module.exports = require(\"jamp3\");","module.exports = require(\"worker_threads\");","export enum JamObjectType {\n\troot = 'root',\n\tuser = 'user',\n\tfolder = 'folder',\n\ttrack = 'track',\n\tstate = 'state',\n\tplaylist = 'playlist',\n\tpodcast = 'podcast',\n\tepisode = 'episode',\n\tseries = 'series',\n\tbookmark = 'bookmark',\n\talbum = 'album',\n\tartist = 'artist',\n\tplayqueue = 'playqueue',\n\tradio = 'radio'\n}\n\nexport enum RootScanStrategy {\n\tauto = 'auto',\n\tartistalbum = 'artistalbum',\n\tcompilation = 'compilation',\n\taudiobook = 'audiobook'\n}\n\nexport const AudioMimeTypes: { [ext: string]: string } = {\n\tmp3: 'audio/mpeg',\n\tm4a: 'audio/mp4',\n\tmp4: 'audio/mp4',\n\togg: 'audio/ogg',\n\toga: 'audio/ogg',\n\tflv: 'aaudio/x-flv',\n\tflac: 'audio/flac',\n\twebma: 'audio/webm',\n\twebm: 'audio/webm',\n\twav: 'audio/wav'\n};\n\nexport enum WaveformFormatType {\n\tsvg = 'svg',\n\tjson = 'json',\n\tdat = 'dat'\n}\n\nexport enum AudioFormatType {\n\tmp3 = 'mp3',\n\tm4a = 'm4a',\n\tmp4 = 'mp4',\n\togg = 'ogg',\n\toga = 'oga',\n\tflv = 'flv',\n\tflac = 'flac',\n\twebma = 'webma',\n\twav = 'wav'\n}\n\nexport const VideoMimeTypes: { [ext: string]: string } = {\n\tmp4: 'audio/mp4',\n\tm4v: 'audio/mp4',\n\togv: 'audio/ogg',\n\twebmv: 'audio/webm',\n\twebm: 'audio/webm'\n};\n\nexport enum FolderType {\n\tunknown = 'unknown',\n\tartist = 'artist',\n\tcollection = 'collection',\n\talbum = 'album',\n\tmultialbum = 'multialbum',\n\textras = 'extras'\n}\n\nexport enum PodcastStatus {\n\t'new' = 'new',\n\tdownloading = 'downloading',\n\tcompleted = 'completed',\n\terror = 'error',\n\tdeleted = 'deleted'\n\t// skipped = 'skipped'\n}\n\nexport const FolderTypeImageName: { [foldertype: string]: string } = {\n\tunknown: 'folder',\n\tartist: 'artist',\n\tcollection: 'folder',\n\talbum: 'cover',\n\tmultialbum: 'cover',\n\textras: 'folder'\n};\n\nexport enum ArtworkImageType {\n\tfront = 'front',\n\tback = 'back',\n\tbooklet = 'booklet',\n\tmedium = 'medium',\n\ttray = 'tray',\n\tobi = 'obi',\n\tspine = 'spine',\n\ttrack = 'track',\n\tliner = 'liner',\n\tsticker = 'sticker',\n\tposter = 'poster',\n\twatermark = 'watermark',\n\traw = 'raw',\n\tunedited = 'unedited',\n\tother = 'other',\n\tartist = 'artist'\n}\n\nexport const FolderTypesAlbum = [FolderType.album, FolderType.multialbum];\n\nexport enum DatabaseQuerySortType {\n\tascending, descending\n}\n\nexport enum AlbumType {\n\tunknown = 'unknown',\n\talbum = 'album',\n\tcompilation = 'compilation',\n\tlive = 'live',\n\tbootleg = 'bootleg',\n\tsoundtrack = 'soundtrack',\n\taudiobook = 'audiobook',\n\tep = 'ep',\n\tsingle = 'single',\n\tseries = 'series'\n}\n\nexport const AlbumTypesArtistMusic = [AlbumType.album, AlbumType.live, AlbumType.bootleg, AlbumType.ep, AlbumType.single];\n\nexport enum FileTyp {\n\tUNKNOWN = 'unknown',\n\tAUDIO = 'audio',\n\tIMAGE = 'image',\n\tTAG = 'tag',\n\tBACKUP = 'backup',\n\tOTHER = 'other'\n}\n\nexport enum LastFMLookupType {\n\talbum = 'album',\n\talbumToptracks = 'album-toptracks',\n\tartist = 'artist',\n\ttrack = 'track',\n\ttrackSimilar = 'track-similar',\n\tartistToptracks = 'artist-toptracks'\n}\n\nexport enum MusicBrainzLookupType {\n\tarea = 'area',\n\tartist = 'artist',\n\tcollection = 'collection',\n\tevent = 'event',\n\tinstrument = 'instrument',\n\tlabel = 'label',\n\tplace = 'place',\n\trecording = 'recording',\n\trelease = 'release',\n\treleaseGroup = 'release-group',\n\tseries = 'series',\n\twork = 'work',\n\turl = 'url'\n}\n\nexport enum MusicBrainzSearchType {\n\tartist = 'artist',\n\tlabel = 'label',\n\trecording = 'recording',\n\trelease = 'release',\n\treleaseGroup = 'release-group',\n\twork = 'work',\n\tarea = 'area'\n}\n\nexport enum CoverArtArchiveLookupType {\n\trelease = 'release',\n\treleaseGroup = 'release-group'\n}\n\nexport enum TrackTagFormatType {\n\tnone = 'none',\n\tffmpeg = 'ffmpeg',\n\tid3v20 = 'id3v20',\n\tid3v21 = 'id3v21',\n\tid3v22 = 'id3v22',\n\tid3v23 = 'id3v23',\n\tid3v24 = 'id3v24',\n\tid3v1 = 'id3v1',\n\tvorbis = 'vorbis'\n}\n\nexport enum MusicBrainzAlbumPrimaryType {\n\talbum = 'Album',\n\tsingle = 'Single',\n\tep = 'EP',\n\tbroadcast = 'Broadcast',\n\tother = 'Other'\n}\n\nexport enum MusicBrainzAlbumSecondaryType {\n\tcompilation = 'Compilation',\n\tsoundtrack = 'Soundtrack',\n\tspokenword = 'Spokenword',\n\tinterview = 'Interview',\n\taudiobook = 'Audiobook',\n\taudiodrama = 'Audio drama',\n\tlive = 'Live',\n\tremix = 'Remix',\n\tdjmix = 'DJ-mix',\n\tmixtape = 'Mixtape'\n}\n\nexport const MUSICBRAINZ_VARIOUS_ARTISTS_ID = '89ad4ac3-39f7-470e-963a-56509c546377';\nexport const MUSICBRAINZ_VARIOUS_ARTISTS_NAME = 'Various Artists';\n\nexport const cUnknownArtist = '[Unknown Artist]';\nexport const cUnknownAlbum = '[Unknown Album]';\n\nexport enum TrackHealthID {\n\ttagValuesExists = 'track.tag.values.exists',\n\tid3v2Exists = 'track.mp3.id3v2.exists',\n\tid3v2Valid = 'track.mp3.id3v2.valid',\n\tid3v2Garbage = 'track.mp3.id3v2.garbage.frames',\n\tmp3HeaderExists = 'track.mp3.vbr.header.exists',\n\tmp3HeaderValid = 'track.mp3.vbr.header.valid',\n\tmp3MediaValid = 'track.mp3.media.valid',\n\tflacMediaValid = 'track.flac.media.valid',\n\tid3v2NoId3v1 = 'track.mp3.id3v2.no.id3v1',\n\tmp3Garbage = 'track.mp3.garbage.data'\n}\n\nexport enum FolderHealthID {\n\talbumTagsExists = 'folder.album.tags.exists',\n\talbumMBIDExists = 'folder.album.mbid.exists',\n\talbumTracksComplete = 'folder.album.tracks.complete',\n\talbumNameConform = 'folder.album.name.conform',\n\talbumImageExists = 'folder.album.image.exists',\n\talbumImageValid = 'folder.album.image.valid',\n\talbumImageQuality = 'folder.album.image.quality',\n\tartistNameConform = 'folder.artist.name.conform',\n\tartistImageExists = 'folder.artist.image.exists',\n\tartistImageValid = 'folder.artist.image.valid'\n}\n\nexport const AudioFormats = ['mp3', 'm4a', 'mp4', 'ogg', 'oga', 'flv', 'flac', 'webma', 'wav'];\nexport const DownloadFormats = ['zip', 'tar'];\nexport const DefaultDownloadFormat = 'zip';\nexport const WaveformFormats = ['svg', 'json', 'dat'];\nexport const WaveformDefaultFormat = WaveformFormatType.svg;\n","module.exports = require(\"path\");","import ffmpeg from 'fluent-ffmpeg';\nimport {fileSuffix} from '../../../utils/fs-utils';\n\n// \t// ffmpeg -i input.mp3 -map_metadata -1 -c:a copy -c:v copy output.mp3\n\nexport async function rewriteWriteFFmpeg(filename: string, destination: string): Promise<void> {\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst proc = ffmpeg({source: filename})\n\t\t\t.addOption('-c:a', 'copy')\n\t\t\t.addOption('-c:v', 'copy')\n\t\t\t.addOption('-map_metadata', '-1')\n\t\t\t.output(destination)\n\t\t\t.format(fileSuffix(filename));\n\t\tproc.on('end', () => {\n\t\t\tresolve();\n\t\t}).on('error', err => {\n\t\t\treject(err);\n\t\t});\n\t\tproc.run();\n\t});\n}\n","module.exports = require(\"fluent-ffmpeg\");"],"sourceRoot":""}